**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group: 10    |
|-----------------|
| Mohamed Ebdalla                |   
| Aryan Karadia              |   
| Raisa Rafi               |   
| Zoraiz Khan             |   

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

We are testing all 5 methods of org.jfree.data.DataUtilities and we have chosen 5 other methods from org.jfree.data.Range to test as mentioned in the assignment guideline.

The testing strategy for unit testing involves testing individual components of the software in isolation. The test-case design approach is based on black-box techniques, where the internal workings of the component are not considered, and testing is done based on input and output.

Equivalence classes are used to partition the input space into classes that are expected to exhibit similar behavior. For example, the tests calculateColumnTotalWithMaxColumns, calculateColumnTotalWithThreeColumn, and calculateColumnTotalForTwoValues are seen as testing different equivalence classes of the number of columns.

Boundary value analysis is used to test the boundaries of the input space, which are often sources of errors. Tests like correctLowerBoundForPositiveRange, correctLowerBoundForNegativeRange, correctUpperBoundForPositiveRange, and correctUpperBoundForNegativeRange apply this technique.

Mocking is beneficial as it allows for the isolation of the component being tested, making the tests more reliable and faster. However, it can lead to oversimplification of the system interactions and might miss some integration issues.

### org.jfree.data.DataUtilities
| Method Name           | Method Usage (return type)| What We Are Testing |
|------------------------------------------------| -------------------------- | ---------- |
| calculateColumnTotal(Values2D data, int column)| Returns the sum of the values in one column of the supplied data table. (static double) | Correct return type and value, throws exception with invalid input |
| calculateRowTotal(Values2D data, int row)      | Returns the sum of the values in one row of the supplied data table. (static double) | Correct return type and value, throws exception with invalid input |
| createNumberArray(double[] data)               | Constructs an array of Number objects from an array of double primitives. (static java.lang.Number[]) | Correct return type and value, throws exception with invalid input |
| createNumberArray2D(double[][] data)           | Constructs an array of arrays of Number objects from a corresponding structure containing double primitives. (static java.lang.Number[][]) | Correct return type and value, throws exception with invalid input |
| getCumulativePercentages(KeyedValues data)     |  Returns a KeyedValues instance that contains the cumulative percentage values for the data in another KeyedValues instance. (static KeyedValues) | Correct return type and value, throws exception with invalid input |

### Tests for Range class
getLowerBoundReturnsCorrectValue: This test case is checking the lower boundary of the range. It falls under boundary value analysis.

correctLowerBoundForPositiveRange: This test case is checking the lower boundary for a positive range. It falls under boundary value analysis.

correctLowerBoundForNegativeRange: This test case is checking the lower boundary for a negative range. It falls under boundary value analysis.

getUpperBoundReturnsCorrectValue: This test case is checking the upper boundary of the range. It falls under boundary value analysis.

correctUpperBoundForPositiveRange: This test case is checking the upper boundary for a positive range. It falls under boundary value analysis.

correctUpperBoundForNegativeRange: This test case is checking the upper boundary for a negative range. It falls under boundary value analysis.

valueWithinRange: This test case is checking if a value within the range is correctly identified. It falls under equivalence partitioning.

valueOnLowerBoundOfRange: This test case is checking if a value on the lower boundary is correctly identified. It falls under boundary value analysis.

valueOnUpperBoundOfRange: This test case is checking if a value on the upper boundary is correctly identified. It falls under boundary value analysis.

valueLowerThanLowerBound: This test case is checking if a value below the lower boundary is correctly identified. It falls under boundary value analysis.

valueHigherThanUpperBound: This test case is checking if a value above the upper boundary is correctly identified. It falls under boundary value analysis.

constrainValueWithinRange: This test case is checking if a value within the range is correctly constrained. It falls under equivalence partitioning.

constrainValueOnLowerBoundOfRange: This test case is checking if a value on the lower boundary is correctly constrained. It falls under boundary value analysis.

constrainValueOnUpperBoundOfRange: This test case is checking if a value on the upper boundary is correctly constrained. It falls under boundary value analysis.

constrainValueBelowLowerBound: This test case is checking if a value below the lower boundary is correctly constrained. It falls under boundary value analysis.

constrainValueAboveUpperBound: This test case is checking if a value above the upper boundary is correctly constrained. It falls under boundary value analysis.

rangesWithSameBoundariesIntersect: This test case is checking if two ranges with the same boundaries intersect. It falls under equivalence partitioning.

rangeNestingAnotherRangeIntersect: This test case is checking if a range that nests another range intersects. It falls under equivalence partitioning.

rangeNestedByAnotherRangeIntersect: This test case is checking if a range that is nested by another range intersects. It falls under equivalence partitioning.

rangeIntesectingFromUpperBoundOnly: This test case is checking if a range that intersects from the upper bound only intersects. It falls under boundary value analysis.

rangeIntesectingFromLowerBoundOnly: This test case is checking if a range that intersects from the lower bound only intersects. It falls under boundary value analysis.

notIntersectingIfOnlyUpperBoundTouchingAnotherRange: This test case is checking if a range that only touches the upper bound of another range does not intersect. It falls under boundary value analysis.

notIntersectingIfOnlyLowerBoundTouchingAnotherRange: This test case is checking if a range that only touches the lower bound of another range does not intersect. It falls under boundary value analysis.

rangeSeperatedByGapNearUpperrBoundDoNotIntersect: This test case is checking if a range that is separated by a gap near the upper bound does not intersect. It falls under boundary value analysis.

rangeSeperatedByGapNearLowerBoundDoNotIntersect: This test case is checking if a range that is separated by a gap near the lower bound does not intersect. It falls under boundary value analysis.

### org.jfree.data.Range
| Method Name           | Method Usage (return type)| What We Are Testing |
|------------------------------------------------| -------------------------- | ---------- |
| contains(double value)| Returns true if the specified value is within the range and false otherwise. (boolean) | Correct return type and value, throws exception with invalid input |
| constrain(double value) | Returns the value within the range that is closest to the specified value. (double) | Correct return type and value, throws exception with invalid input |
| intersects(double lower, double upper) | Returns true if the range intersects (overlaps) with the specified range, and false otherwise. (boolean) | Correct return type and value, throws exception with invalid input |
| expand(Range range, double lowermargin, double uppermargin) | Creates a new range by adding margins to an existing range. (static Range)| Correct return type and value, throws exception with invalid input |
| combine(Range range1, Range range2) | Creates a new range by combining two existing ranges. (static Range) | Correct return type and value, throws exception with invalid input |

# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
